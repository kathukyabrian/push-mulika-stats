package tech.kitucode;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Hello world!
 */
public class App {
    private static Thread mulikaThread;
    private static final String app = "autogenerated";
    private static final String module = "autogenerated-1";
    private static final int reportInterval = 60000;
    private static final int SERVICE_COUNT = 10;
    private static final String SERVICE_PREFIX = "autogenerated";
    private static String mulikaUrl = "https://mulika.natujenge.ke/api/statistics/report-list";
    private static String mulikaAPIKey = "eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJwbXV0aXN5YUBtZWxpb3JhLnRlY2giLCJhdXRoIjoiUk9MRV9BUEkiLCJvaWQiOjIsIm90eXBlIjoiQ0xJRU5UIiwiZXhwIjoxOTAxNzgwNDQzfQ.2LdI9Rpu-tu4sN9h3KIGoq61ILdgvj7xQ9Dh_2L3Fei0VutF_JF7UIob5z_OKHV8XWFfW6P1aa0DB2gZH3_iow";

    public static void main(String[] args) {
        System.out.println("About to start stats push thread");
        mulikaThread = new Thread(() -> {
            while (true) {
                try {
                    try {
                        System.out.println("About to sleep for " + reportInterval + " milliseconds");
                        Thread.sleep(reportInterval);
                    } catch (InterruptedException ex) {
                        System.out.println("Thread could not sleep. trying again " + ex);
                        Thread.sleep(reportInterval);
                    }

                    reportStats();

                } catch (InterruptedException e) {
                    System.out.println("received an interrupt signal " + e);
                    break;
                } catch (Exception ex) {
                    System.out.println("Encountered exception. Proceeding " + ex);
                }
            }
        }, "mulika-thread");

        System.out.println("Successfully initialized mulika thread");

        mulikaThread.start();


        System.out.println("Successfully started mulika thread. mulikaUrl = " + mulikaUrl + ", mulikaAPIKey = " + mulikaAPIKey);
    }

    private static void reportStats() {
        try {
            String jsonRequest = getRequests();

            Map<String, String> headers = new HashMap<>();
            headers.put("Authorization", "Bearer " + mulikaAPIKey.trim());
            headers.put("User-Agent", "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.4; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2");

            HTTPResponse response = HTTPClient.send(mulikaUrl, jsonRequest, "POST", "application/json", headers, 5000, 120000);

            System.out.println("mulika|" + "|request :" + jsonRequest + "|response : " + response + "|stats sent");
        } catch (IOException e) {
            System.out.println("mulika|Encountered exception" + e);
        }
    }

    private static String getRequests() throws JsonProcessingException {
        List<Map<String, Object>> mapList = new ArrayList<>();

        for (int i = 0; i <= SERVICE_COUNT; i++) {
            Map<String, Object> requestMap = new HashMap<>();
            String serviceName = SERVICE_PREFIX + "-" + i;
            requestMap.put("id", serviceName);
            requestMap.put("name", serviceName);
            requestMap.put("type", "SERVICE");
            requestMap.put("applicationName", app);
            requestMap.put("moduleName", module);
            requestMap.put("transactionTime", (int) (Math.random() * (100 - 90)) + 90);
            requestMap.put("totalRequests", (int) (Math.random() * (1000 - 900)) + 900);
            requestMap.put("successTotal", (int) (Math.random() * (900 - 500)) + 500);
//            requestMap.put("successTotal", requestMap.get("totalRequests"));
            requestMap.put("queueSize", (int) (Math.random() * (150 - 100)) + 100);
//            requestMap.put("queueSize", 0);
            requestMap.put("rejectedMessages", 0);

            mapList.add(requestMap);
        }


        ObjectMapper objectMapper = new ObjectMapper();

        return objectMapper.writeValueAsString(mapList);
    }


}
